{"version":3,"sources":["webpack:///path---package-relude-parse-5a52309f25381373922c.js","webpack:///./.cache/json/package-relude-parse.json"],"names":["webpackJsonp","1414","module","exports","data","package","type","id","name","version","category","flags","platforms","description","keywords","license","updated","stars","score","quality","popularity","maintenance","readme","homepageUrl","repositoryUrl","npmUrl","issuesUrl","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,SAAWC,KAAA,YAAAC,GAAA,eAAAC,KAAA,eAAAC,QAAA,QAAAC,SAAA,UAAAC,SAAAC,WAAA,kBAAAC,YAAA,8BAAAC,UAAA,WAAAC,QAAA,MAAAC,QAAA,2BAAAC,MAAA,GAAAC,MAAA,kBAAAC,QAAA,kBAAAC,WAAA,mBAAAC,YAAA,kBAAAC,OAAA;AAA0+zEC,YAAA,gDAAAC,cAAA,yCAAAC,OAAA,6CAAAC,UAAA,gDAAAC,KAAA,0BAA6uKC,aAAgBrB,GAAA","file":"path---package-relude-parse-5a52309f25381373922c.js","sourcesContent":["webpackJsonp([229139762612574],{\n\n/***/ 1414:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"package\":{\"type\":\"published\",\"id\":\"relude-parse\",\"name\":\"relude-parse\",\"version\":\"0.8.0\",\"category\":\"library\",\"flags\":[],\"platforms\":[\"browser\",\"node\"],\"description\":\"Monadic parsing with Relude\",\"keywords\":[\"parsing\"],\"license\":\"MIT\",\"updated\":\"2020-06-26T21:15:46.337Z\",\"stars\":26,\"score\":0.6113400696511464,\"quality\":0.8456689416111867,\"popularity\":0.05010231773469999,\"maintenance\":0.9717245027447012,\"readme\":\"<h1 id=\\\"relude-parse\\\"><a href=\\\"#relude-parse\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>relude-parse</h1>\\n<p><a href=\\\"https://github.com/reazen/relude-parse/actions\\\"><img src=\\\"https://img.shields.io/github/workflow/status/reazen/relude-parse/CI/master\\\" alt=\\\"GitHub CI\\\"></a>\\n<a href=\\\"https://www.npmjs.com/package/relude-parse\\\"><img src=\\\"https://img.shields.io/npm/v/relude-parse.svg\\\" alt=\\\"npm\\\"></a></p>\\n<h1 id=\\\"overview\\\"><a href=\\\"#overview\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Overview</h1>\\n<p><code>ReludeParse</code> is a pure-functional string parsing library for\\nReasonML/Bucklescript, built on top of the functional programming types and\\ntype classes provided by <a href=\\\"https://github.com/reazen/relude\\\">Relude</a>.</p>\\n<p><code>ReludeParse</code> was influenced by <a href=\\\"https://github.com/purescript-contrib/purescript-string-parsers\\\">purescript-string-parsers</a>, <a href=\\\"https://github.com/deathbeam/parsihax\\\">parsihax</a>, and <a href=\\\"https://github.com/tpolecat/atto\\\">atto</a>, and several of the parsers in the Haskell ecosystem.</p>\\n<h1 id=\\\"getting-started\\\"><a href=\\\"#getting-started\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Getting started</h1>\\n<h2 id=\\\"install-the-library\\\"><a href=\\\"#install-the-library\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Install the library</h2>\\n<div class=\\\"redex-codeblock\\\"><pre class=\\\"hljs lang-bash\\\"><code>// Install the library from npm\\nnpm install --save-dev relude relude-parse\\n// add relude and relude-parse to your bsconfig.json</code></pre></div>\\n<h2 id=\\\"import-the-types-functions-operators-etc\\\"><a href=\\\"#import-the-types-functions-operators-etc\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Import the types, functions, operators, etc.</h2>\\n<p><code>ReludeParse</code> is the root namespace module.</p>\\n<p>In ReasonML/Bucklescript, you can get access to a module's functions in a variety of ways, here\\nare a few examples:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Method 1: Global open (not recommended)</span>\\nopen <span class=\\\"hljs-type\\\">ReludeParse</span>.<span class=\\\"hljs-type\\\">Parser</span>;\\n<span class=\\\"hljs-keyword\\\">let</span> <span class=\\\"hljs-number\\\">_</span> = anyDigit &lt;* eof |&gt; runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// Method 2: Local open (good but more verbose)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> <span class=\\\"hljs-number\\\">_</span> = <span class=\\\"hljs-type\\\">ReludeParse</span>.<span class=\\\"hljs-type\\\">Parser</span>.(anyDigit &lt;* eof |&gt; runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>));\\n\\n<span class=\\\"hljs-comment\\\">// Method 3: Module alias with small global open (tradeoff between 1 and 2 above)</span>\\n<span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">module</span> <span class=\\\"hljs-title\\\">P</span> = <span class=\\\"hljs-title\\\">ReludeParse</span>.<span class=\\\"hljs-title\\\">Parser</span>;\\n<span class=\\\"hljs-title\\\">open</span> <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">Infix</span>; // <span class=\\\"hljs-title\\\">Get</span> <span class=\\\"hljs-title\\\">all</span> <span class=\\\"hljs-title\\\">the</span> <span class=\\\"hljs-title\\\">infix</span> <span class=\\\"hljs-title\\\">operators</span> <span class=\\\"hljs-title\\\">in</span> <span class=\\\"hljs-title\\\">scope</span>\\n<span class=\\\"hljs-title\\\">let</span> <span class=\\\"hljs-title\\\">_</span> = <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">anyDigit</span> &lt;* <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">eof</span> |&gt; <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">runParser</span>(\\\"1\\\");</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>I recommend using method 3 for most cases, but if you are running into conflicts, use method 2.\\nIf you just want to live your life, use method 1.</p>\\n<p>For examples below, I'm going to assume method 3.</p>\\n<p>As a side note, the relude ecosystem prefers the <code>|></code> pipe operator over <code>-></code>, so most\\nfunctions are \\\"significant data last\\\" style, and the \\\"significant data\\\" is typically\\na value of type <code>Parser.t('a)</code>.  This allows you to do things like:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.sepBy(str(<span class=\\\"hljs-string\\\">\\\",\\\"</span>))</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ = <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; (<span class=\\\"hljs-type\\\">P</span>.sepBy (str <span class=\\\"hljs-string\\\">\\\",\\\"</span>))</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>which is the same as below:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.sepBy(str(<span class=\\\"hljs-string\\\">\\\",\\\"</span>), <span class=\\\"hljs-type\\\">P</span>.anyAlpha)</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ = <span class=\\\"hljs-type\\\">P</span>.sepBy (str <span class=\\\"hljs-string\\\">\\\",\\\"</span>) <span class=\\\"hljs-type\\\">P</span>.anyAlpha</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Luckily, either way is perfectly legit, so use whichever style you prefer.</p>\\n<h1 id=\\\"parsers\\\"><a href=\\\"#parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Parsers</h1>\\n<p><code>ReludeParse.Parser.t('a)</code> is a data type which encapsulates the ability to parse a string\\ninto a value of type <code>'a</code>, or fail with a fixed <code>ParseError.t</code> type, which provides an error message and parse position.</p>\\n<p><code>ReludeParse</code> provides a wide variety of low-level, medium-level, and\\nhigh-level parsers which can be composed together to parse just about\\nanything.  Note that there are a few functions (like <code>many</code>) that are not stack safe,\\nso beware when parsing very large strings of repeating characters.  Someday these functions\\nmaybe become stack safe.</p>\\n<p>The parse errors are currently pretty minimal only giving an error message and parse position.\\nSomeday this may improve.</p>\\n<h1 id=\\\"run-a-parser\\\"><a href=\\\"#run-a-parser\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Run a parser</h1>\\n<p>A parser will attempt to consume input from a string until it can successfully finish and produce\\na value or fail.  The parser will only consume enough of the string to satisfy\\nits own parsing needs (whatever it needs to produce the final value), and will leave the rest of the string for the next parser (if any).</p>\\n<p>To run a parser, simply pipe (or pass) it into the <code>P.runParser</code> function, along with the input string:</p>\\n<p>Success example:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// anyDigit will attempt to consume a single character, and succeeds if that character</span>\\n<span class=\\\"hljs-comment\\\">// is a digit 0-9</span>\\n\\n<span class=\\\"hljs-comment\\\">// Pipe operator |&gt;</span>\\n\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"1\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// Or normal function application</span>\\n\\n<span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>, <span class=\\\"hljs-type\\\">P</span>.anyDigit)</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Failure example:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"!\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(ParseError(\\\"Expected a digit\\\"))</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code>let _ =\\n  P.anyDigit |&gt;\\n    ((P.runParser \\\"!\\\") //\\n       ((Belt.Result.Error\\n           (((ParseError (\\\"Expected a digit\\\"))[@explicit_arity ])))[@explicit_arity\\n                                                                    ]))</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>In the event of a failed parse, parsers will (in most cases) back-track so that an alternative\\nparser (if supplied) can pick-up where the previous failed.</p>\\n<p>There is also a <code>P.unParser</code> function, which gives you access to more of the internals\\nin the event of success or failure.  It's called <code>unParser</code> because it unwraps or \\\"lowers\\\" a\\nvalue of type <code>Parser.t('a)</code> to the raw parsing function contained within.</p>\\n<h1 id=\\\"mapping-a-function-over-a-parser\\\"><a href=\\\"#mapping-a-function-over-a-parser\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Mapping a function over a parser</h1>\\n<p>A <code>RelueParse.Parser</code> is a <code>functor</code>, so we can map a pure function over the parser's value.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Warning: int_of_string is unsafe (can throw) - this is just an example</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.<span class=\\\"hljs-built_in\\\">map</span>(int_of_string) |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(1)</span>\\n\\n<span class=\\\"hljs-comment\\\">// &lt;$&gt; map operator version.  &lt;$&gt; is traditionally \\\"function on the left\\\"</span>\\nint_of_string &lt;$&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// &lt;#&gt; flipped map operator version - &lt;#&gt; is function on the right hand side,</span>\\n<span class=\\\"hljs-comment\\\">// which might be more readable for some.</span>\\n<span class=\\\"hljs-comment\\\">// When you see `&lt;#&gt;` just think `.map(...)` from JavaScript</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;#&gt; int_of_string |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>);</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Note: see the monad section for an information on how to handle or produce errors while parsing.</p>\\n<p><code>Parser.t('a)</code> comes with all the bells and whistles that are granted to all\\n<code>functors</code> in relude. This includes:</p>\\n<ul>\\n<li>the <code>map</code> function</li>\\n<li>the <code>&#x3C;$></code> (<code>map</code>) operator</li>\\n<li><code>flipMap</code></li>\\n<li>the <code>&#x3C;#></code> (<code>flipMap</code>) operator</li>\\n<li>the <code>&#x3C;$</code> operator</li>\\n<li>the <code>$></code> operator</li>\\n</ul>\\n<p>These things are all provided \\\"for free\\\" via the <a href=\\\"https://github.com/reazen/relude/blob/master/src/extensions/Relude_Extensions_Functor.re\\\">Relude Functor Extensions</a></p>\\n<p>Note: <code>Parser.t('a)</code> is not a bi-functor - the error type is fixed to\\na known data type for simplicity.</p>\\n<h1 id=\\\"combining-parsers-via-applicative\\\"><a href=\\\"#combining-parsers-via-applicative\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Combining parsers (via Applicative)</h1>\\n<p>A <code>ReludeParse.Parser.t('a)</code> is an <code>applicative functor</code>, so we can combine multiple parsers\\ntogether using a variety of techniques.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Combine two parsers into a tuple of the results (assuming all succeed)</span>\\n<span class=\\\"hljs-type\\\">P</span>.tuple2(<span class=\\\"hljs-type\\\">P</span>.anyDigit, <span class=\\\"hljs-type\\\">P</span>.anyDigit) |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok((\\\"1\\\", \\\"2\\\"))</span>\\n\\n<span class=\\\"hljs-comment\\\">// &lt;^&gt; operator (operator version of tuple2)</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;^&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok((\\\"1\\\", \\\"2\\\"))</span>\\n\\n<span class=\\\"hljs-comment\\\">// Combine more parsers using tuple3 up to tuple5</span>\\n<span class=\\\"hljs-type\\\">P</span>.tuple3(<span class=\\\"hljs-type\\\">P</span>.anyDigit, <span class=\\\"hljs-type\\\">P</span>.anyDigit, <span class=\\\"hljs-type\\\">P</span>.anyDigit)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"123\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok((\\\"1\\\", \\\"2\\\", \\\"3\\\"))</span>\\n\\n<span class=\\\"hljs-comment\\\">// Combine parse results using a function via map2 through map5</span>\\n<span class=\\\"hljs-type\\\">P</span>.map2((a, b) =&gt; a + b, <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt, <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(3)</span>\\n\\n<span class=\\\"hljs-comment\\\">// Combine results from a tuple of parsers using mapTuple2 through mapTuple5</span>\\n(<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt, <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.mapTuple2((a, b) =&gt; a + b)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(3)</span>\\n\\n<span class=\\\"hljs-comment\\\">// Use the *&gt; operator to run two parsers, and only keep the result from the right side</span>\\n<span class=\\\"hljs-comment\\\">// This is useful if you don't care what the left side parser produces (e.g. whitespace)</span>\\n<span class=\\\"hljs-comment\\\">// but you need to consume that input.</span>\\n<span class=\\\"hljs-comment\\\">// `ws` consumes all the whitespace it encounters and throws it away</span>\\n<span class=\\\"hljs-type\\\">P</span>.ws\\n*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"   3\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"3\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// Use the &lt;* operator to run two parsers, and only keep the result from the left side</span>\\n<span class=\\\"hljs-comment\\\">// This is useful if you don't care what the right side parser produces (e.g. whitespace)</span>\\n<span class=\\\"hljs-comment\\\">// but you want to consume that input.</span>\\n<span class=\\\"hljs-comment\\\">// It's common to use this operator with `eof` to make sure you've hit the end of the input</span>\\n<span class=\\\"hljs-comment\\\">// (but you don't care about the value produced by `eof`).</span>\\n<span class=\\\"hljs-comment\\\">// E.g. use both *&gt; and &lt;* to trim whitespace surrounding a value</span>\\n<span class=\\\"hljs-type\\\">P</span>.ws\\n*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit\\n&lt;* <span class=\\\"hljs-type\\\">P</span>.ws\\n&lt;* <span class=\\\"hljs-type\\\">P</span>.eof\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"   3  \\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"3\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// ADVANCED: Incrementally collect parse results using a function and chained &lt;$&gt; map and &lt;*&gt; apply</span>\\n<span class=\\\"hljs-comment\\\">// operators.</span>\\n<span class=\\\"hljs-keyword\\\">let</span> add3 = (a, b, <span class=\\\"hljs-built_in\\\">c</span>) =&gt; a + b + <span class=\\\"hljs-built_in\\\">c</span>;\\nadd3\\n&lt;$&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&lt;*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&lt;*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"123\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(6)</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Many of these functions and operators come for free for any Applicative via <a href=\\\"https://github.com/reazen/relude/blob/master/src/extensions/Relude_Extensions_Apply.re\\\">Relude Apply Extensions</a></p>\\n<h1 id=\\\"sequencing-parsers-via-monads\\\"><a href=\\\"#sequencing-parsers-via-monads\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Sequencing parsers (via Monads)</h1>\\n<p>A <code>Parser.t('a)</code> is also a <code>monad</code>, so you can put pure values directly into a parser using <code>pure</code>,\\nand more importantly, you can sequence parsers using <code>flatMap</code>, <code>bind</code>, or the <code>>>=</code> operator.\\n<code>bind</code>, <code>flatMap</code> and <code>>>=</code> all basically do the same thing - the take a <code>Parser.t('a)</code>, a function from <code>'a => Parser.t('b)</code> and give you a <code>Parser.t('b)</code>.  What this basically means is that you can \\\"run\\\" a parser to\\nproduce a value (note: I don't mean return a value, but produce a value inside your monadic flow), then use that value to create a new parser with which to continue processing.  Note that you can't do that with the functors and applicative-based parsing, because <code>map</code>/<code>apply</code>/<code>&#x3C;*></code> and friends don't give you the opportunity to produce a new parser based on the value - you can only apply functions inside the context of a parser.</p>\\n<p>For intuition, <code>flatMap</code> is an apt name for this function because if you have a <code>myToOfA: t('a)</code>, a function <code>aToTOfB: 'a => t('b)</code>, and you do <code>myTOfA |> map(aToTOfB)</code> you'll get a <code>t(t('b))</code>.  A monad has the ability to \\\"flatten\\\" itself when in a nested structure like this, i.e. <code>flatten: t(t('b)) => t('b)</code>.  In some languages <code>flatten</code> is often named <code>join</code> - like you are flattening or joining a nested structure into a single structure.  <code>flatMap</code> can be implemented in terms of <code>map</code> and <code>flatten</code>, and flatten can be implmeented in terms of <code>flatMap</code>.</p>\\n<p>So <code>flatMap</code> is mapping a monadic function <code>'a => t('b)</code> over a <code>t('a)</code>, and then flattening the resulting <code>t(t('b))</code> to just <code>t('b)</code>.</p>\\n<p>The true power of monads is the ability to produce a new monadic value (i.e. a new parser) mid-flow, which can be used for producing and handling errors, or forking the parse flow to do something different, based on what you've previously parsed.</p>\\n<p>Note that monads have \\\"fail-fast\\\" semantics, because if a parser fails to produce a value, it's\\nnot possible for the next parser to accept a value (because there is none).  In other words,\\nif a parser fails at some point in a chain, the rest of the parsers will not run.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Lift a pure value into a parser.</span>\\n<span class=\\\"hljs-comment\\\">// As you can see the parser just produces the given value regardless of the string.</span>\\n<span class=\\\"hljs-type\\\">P</span>.pure(<span class=\\\"hljs-number\\\">3</span>)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"abcdef\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(3)</span>\\n\\n<span class=\\\"hljs-comment\\\">// Sequence parse operations using flatMap.</span>\\n<span class=\\\"hljs-comment\\\">// In this example we read a single digit as an int, then use that value</span>\\n<span class=\\\"hljs-comment\\\">// to read a series of letters, and expect to consume the whole input.</span>\\n<span class=\\\"hljs-comment\\\">// This is sequencing because we use the result of one parser to determine</span>\\n<span class=\\\"hljs-comment\\\">// the next parser to run.</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.flatMap(<span class=\\\"hljs-built_in\\\">count</span> =&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.times(<span class=\\\"hljs-built_in\\\">count</span>) &lt;* <span class=\\\"hljs-type\\\">P</span>.eof)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.<span class=\\\"hljs-built_in\\\">map</span>(chars =&gt; <span class=\\\"hljs-type\\\">Relude</span>.<span class=\\\"hljs-type\\\">List</span>.<span class=\\\"hljs-type\\\">String</span>.<span class=\\\"hljs-built_in\\\">join</span>(chars))\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"3abc\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"abc\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// Sequence using &gt;&gt;= (flatMap/bind) and &lt;#&gt; (map) operators.</span>\\n<span class=\\\"hljs-comment\\\">// If you are coming from JS -</span>\\n<span class=\\\"hljs-comment\\\">// Don't be afraid of the operators - when you see &gt;&gt;= read \\\".flatMap(...)\\\"</span>\\n<span class=\\\"hljs-comment\\\">// and when you see \\\"&lt;#&gt;\\\" read \\\".map(...)\\\".  Eventually these will become</span>\\n<span class=\\\"hljs-comment\\\">// second nature.</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&gt;&gt;= (<span class=\\\"hljs-built_in\\\">count</span> =&gt; <span class=\\\"hljs-type\\\">P</span>.times(<span class=\\\"hljs-built_in\\\">count</span>, <span class=\\\"hljs-type\\\">P</span>.anyAlpha) &lt;* <span class=\\\"hljs-type\\\">P</span>.eof)\\n&lt;#&gt; <span class=\\\"hljs-type\\\">Relude</span>.<span class=\\\"hljs-type\\\">List</span>.<span class=\\\"hljs-type\\\">String</span>.<span class=\\\"hljs-built_in\\\">join</span>\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"3abc\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"abc\\\")</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Many of these functions come for free for any Monad via <a href=\\\"https://github.com/reazen/relude/blob/master/src/extensions/Relude_Extensions_Monad.re\\\">Relude Monad Extensions</a></p>\\n<h1 id=\\\"add-validation-and-error-handling-in-a-parse-chain\\\"><a href=\\\"#add-validation-and-error-handling-in-a-parse-chain\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Add validation and error handling in a parse chain</h1>\\n<p>You can also use the monadic behavior to optionally fail a parse inside a\\n<code>bind</code>/<code>flatMap</code>/<code>>>=</code> function.  Note that you can't fail a parse inside a <code>map</code>\\nbecause map uses a pure function from <code>'a => 'b</code>, so there's no way to indicate failure\\nof the parse - you are only allowed to produce a new value <code>'b</code> <em>inside</em> the context of an existing\\nparser.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&gt;&gt;= (\\n  <span class=\\\"hljs-built_in\\\">count</span> =&gt;\\n    <span class=\\\"hljs-keyword\\\">if</span> (<span class=\\\"hljs-built_in\\\">count</span> &gt;= <span class=\\\"hljs-number\\\">5</span>) {\\n      <span class=\\\"hljs-comment\\\">// P.fail is a parser that always fails with the given message</span>\\n      <span class=\\\"hljs-comment\\\">// just like P.pure always succeeds with the given value.</span>\\n      <span class=\\\"hljs-comment\\\">// Using &gt;&gt;= and fail is a common way to inject validations and raise errors.</span>\\n      <span class=\\\"hljs-type\\\">P</span>.fail(<span class=\\\"hljs-string\\\">\\\"The count cannot be &gt;= 5\\\"</span>);\\n    } <span class=\\\"hljs-keyword\\\">else</span> {\\n      <span class=\\\"hljs-comment\\\">// Now that we have a valid count, carry on</span>\\n      <span class=\\\"hljs-type\\\">P</span>.times(<span class=\\\"hljs-built_in\\\">count</span>, <span class=\\\"hljs-type\\\">P</span>.anyAlpha) &lt;* eof;\\n    }\\n)\\n&lt;#&gt; <span class=\\\"hljs-type\\\">Relude</span>.<span class=\\\"hljs-type\\\">List</span>.<span class=\\\"hljs-type\\\">String</span>.<span class=\\\"hljs-built_in\\\">join</span>\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"9abc\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(ParseError(\\\"The count cannot be &gt;= 5\\\"))</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">3321</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>The <code>filter</code> function in <code>ReludeParse</code> is basically for this purpose.  Filter produces its\\nown generic error message if the predicate fails, but you can customize it like below:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.<span class=\\\"hljs-built_in\\\">filter</span>(a =&gt; a &gt; <span class=\\\"hljs-number\\\">5</span>)\\n&lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected an int greater than 5\\\"</span>;</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ =\\n  (<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt |&gt; (<span class=\\\"hljs-type\\\">P</span>.filter (<span class=\\\"hljs-keyword\\\">fun</span> a  -&gt; a &gt; <span class=\\\"hljs-number\\\">5</span>))) &lt;?&gt;\\n    <span class=\\\"hljs-string\\\">\\\"Expected an int greater than 5\\\"</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"trying-multiple-parsers-via-alt\\\"><a href=\\\"#trying-multiple-parsers-via-alt\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Trying multiple parsers (via Alt)</h1>\\n<p><code>ReludeParse.Parser.t('a)</code> is also an <code>alt</code> functor, which means you can try one parser, and\\nif it fails, try another, as many times as you want.</p>\\n<p>The <code>&#x3C;|></code> operator is used for this - think of the <code>&#x3C;|></code> operator as an <code>orElse</code> function.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"9\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"9\\\")</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"a\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"a\\\")</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"!\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(...)</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">967</span>: syntax error, consider adding a `;<span class=\\\"hljs-char\\\">' before</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<p><code>&#x3C;|></code> can be chained as many times as you want - it attempts each parser left-to-right.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"a\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"b\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"c\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"d\\\"</span>) ...and so on</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">967</span>: syntax error, consider adding a `;<span class=\\\"hljs-char\\\">' before</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<p>If none of the parsers succeed, it will return the error of the last parser, so a common\\ntechnique is to use <code>&#x3C;?></code> to add a custom error message at the end</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"a\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"b\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"c\\\"</span>) &lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected a, b, or c\\\"</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ =\\n  (((<span class=\\\"hljs-type\\\">P</span>.str <span class=\\\"hljs-string\\\">\\\"a\\\"</span>) &lt;|&gt; (<span class=\\\"hljs-type\\\">P</span>.str <span class=\\\"hljs-string\\\">\\\"b\\\"</span>)) &lt;|&gt; (<span class=\\\"hljs-type\\\">P</span>.str <span class=\\\"hljs-string\\\">\\\"c\\\"</span>)) &lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected a, b, or c\\\"</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Sometimes when using <code>&#x3C;|></code> with more complex parsers, the first parser might consume some input\\nbefore failing, which might mess up the next parser in the <code>&#x3C;|></code> chain.  Use the <code>tries</code>\\nfunction to force a parser to back-track all the way to it's original position if it fails.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Without tries, this fails, because the first parser consumes the 9, then fails,</span>\\n<span class=\\\"hljs-comment\\\">// but the next parser wants to consume a digit then a letter.  Using tries makes the</span>\\n<span class=\\\"hljs-comment\\\">// parser fully back-track on failure if it had consumed any input.</span>\\n<span class=\\\"hljs-type\\\">P</span>.tries(<span class=\\\"hljs-type\\\">P</span>.anyDigit *&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit) <span class=\\\"hljs-comment\\\">// parse a digit, throw it away, then parse another digit</span>\\n&lt;|&gt; (<span class=\\\"hljs-type\\\">P</span>.anyDigit *&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha) <span class=\\\"hljs-comment\\\">// parse a digit,throw it away, then parse a letter</span>\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"9a\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"a\\\")</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"customizing-the-error-message\\\"><a href=\\\"#customizing-the-error-message\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Customizing the error message</h1>\\n<p>Use the <code>&#x3C;?></code> operator to put a custom error message on a parser.  This is useful\\nif you are composing a more complex parser from smaller parsers, and want a more meaningful error\\nmessage if the parser fails.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.many1(<span class=\\\"hljs-type\\\">P</span>.anyDigit)\\n&lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected one or more digits\\\"</span>\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"abc\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(ParseError(\\\"Expected one or more digits\\\"))</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code>let _ =\\n  ((P.many1 P.anyDigit) &lt;?&gt; \\\"Expected one or more digits\\\") |&gt;\\n    ((P.runParser \\\"abc\\\") //\\n       ((Belt.Result.Error\\n           (((ParseError (\\\"Expected one or more digits\\\"))[@explicit_arity ])))\\n       [@explicit_arity ]))</code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"checking-that-all-input-is-consumed\\\"><a href=\\\"#checking-that-all-input-is-consumed\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Checking that all input is consumed</h1>\\n<p>To make sure that all the input in the string has been consumed, use the <code>eof</code> (end-of-file) parser.\\nIt's common to use <code>&#x3C;* eof</code> to parse the end of input, because <code>&#x3C;*</code> will just keep what's on\\nthe left side of <code>eof</code>.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;* <span class=\\\"hljs-type\\\">P</span>.eof <span class=\\\"hljs-comment\\\">// Succeeds for \\\"3\\\" but fails for \\\"3 \\\"</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">1444</span>: syntax error, consider adding a `;<span class=\\\"hljs-char\\\">' before</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"debugging\\\"><a href=\\\"#debugging\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Debugging</h1>\\n<p>Use <code>tap</code> to inspect the result of a successful parse, and the parse position.</p>\\n<p>Use the <code>tapLog</code> function to inject some basic logging anywhere in a parser composition.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code>anyDigit *&gt; anyDigit *&gt; anyAlpha |&gt; tapLog <span class=\\\"hljs-comment\\\">// etc.</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">2990</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"examples\\\"><a href=\\\"#examples\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Examples</h1>\\n<h2 id=\\\"ipv4\\\"><a href=\\\"#ipv4\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>IPv4</h2>\\n<p>E.g. <code>127.0.0.1</code></p>\\n<p>There are many different ways to compose a parser to parse values like this.  Below are just\\nsome examples to show different techniques.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-keyword\\\">type</span> t = | <span class=\\\"hljs-type\\\">IPv4</span>(int, int, int, int);\\n<span class=\\\"hljs-keyword\\\">let</span> make = (a, b, <span class=\\\"hljs-built_in\\\">c</span>, d) =&gt; <span class=\\\"hljs-type\\\">IPv4</span>(a, b, <span class=\\\"hljs-built_in\\\">c</span>, d);\\n\\n<span class=\\\"hljs-comment\\\">// Using a tuple and mapTuple4</span>\\n<span class=\\\"hljs-comment\\\">// parse a short (up to 255) and the dot separators</span>\\n(\\n  anyPositiveShort &lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>),\\n  anyPositiveShort &lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>),\\n  anyPositiveShort &lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>),\\n  anyPositiveShort\\n)\\n|&gt; mapTuple4(make)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// Using nested flatMaps and a final map at the end.</span>\\n<span class=\\\"hljs-comment\\\">// These are nested because we have to collect each value as we go, and it has to</span>\\n<span class=\\\"hljs-comment\\\">// be in scope at the end when we want to construct our final value.</span>\\n<span class=\\\"hljs-comment\\\">// Note: language support for sequences of monadic binds (e.g. do notation or the</span>\\n<span class=\\\"hljs-comment\\\">// upcoming let+/let* bindings in OCaml, this becomes a beautiful, flat expression,</span>\\n<span class=\\\"hljs-comment\\\">// almost like imperative code, but with pure FP data structures and functions!</span>\\nanyPositiveShort\\n&gt;&gt;= (\\n  a =&gt;\\n    str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)\\n    &gt;&gt;= (\\n      <span class=\\\"hljs-number\\\">_</span> =&gt;\\n        anyPositiveShort\\n        &gt;&gt;= (\\n          b =&gt;\\n            str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)\\n            &gt;&gt;= (\\n              <span class=\\\"hljs-number\\\">_</span> =&gt;\\n                anyPositiveShort\\n                &gt;&gt;= (\\n                  <span class=\\\"hljs-built_in\\\">c</span> =&gt;\\n                    str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)\\n                    &gt;&gt;= (\\n                      <span class=\\\"hljs-number\\\">_</span> =&gt;\\n                        anyPositiveShort\\n                        &lt;#&gt; (\\n                          d =&gt;\\n                            make(a, b, <span class=\\\"hljs-built_in\\\">c</span>, d)\\n                        )\\n                    )\\n                )\\n            )\\n        )\\n    )\\n)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// With a monadic flow, another technique is to map each successive result into</span>\\n<span class=\\\"hljs-comment\\\">// an ever-expanding tuple, and pass the values along that way. This allows you</span>\\n<span class=\\\"hljs-comment\\\">// to have a more flat structure, at the</span>\\n<span class=\\\"hljs-comment\\\">// expense of wrapping and unwrapping tuples at each step.</span>\\n\\n<span class=\\\"hljs-comment\\\">// Using &lt;$&gt; and &lt;*&gt; (with &lt;* and *&gt; helpers)</span>\\n<span class=\\\"hljs-comment\\\">// Our make function is (int, int, int, int) =&gt; IPv4</span>\\n<span class=\\\"hljs-comment\\\">// The first map &lt;$&gt; creates a `Parser.t((int, int, int) =&gt; IPv4)`</span>\\n<span class=\\\"hljs-comment\\\">// and each successive &lt;*&gt; fills another slot in our function,</span>\\n<span class=\\\"hljs-comment\\\">// until we finally collect the 4 args.</span>\\n<span class=\\\"hljs-comment\\\">// The `&lt;* str(\\\".\\\")` reads a \\\".\\\", but throw it away.</span>\\nmake \\n&lt;$&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n&lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)          <span class=\\\"hljs-comment\\\">// read and ignore .</span>\\n&lt;*&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n&lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)          <span class=\\\"hljs-comment\\\">// read and ignore .</span>\\n&lt;*&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n&lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)          <span class=\\\"hljs-comment\\\">// read and ignore .</span>\\n&lt;*&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>)\\n\\n<span class=\\\"hljs-comment\\\">// Using sepBy</span>\\n<span class=\\\"hljs-comment\\\">// Note that sepBy produces a list of the values produced by the value parser,</span>\\n<span class=\\\"hljs-comment\\\">// so we have to manually validate that we got the correct number in our list.</span>\\n<span class=\\\"hljs-comment\\\">// This is done using `&gt;&gt;=`, so we can fail the parse with the `fail` function,</span>\\n<span class=\\\"hljs-comment\\\">// which produces a failing parser.  If we get the 4 values we need, we use pure</span>\\n<span class=\\\"hljs-comment\\\">// to create a parser that produces our desired IPv4 value.</span>\\nanyPositiveShort\\n|&gt; sepBy(str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>))\\n&gt;&gt;= (\\n  <span class=\\\"hljs-comment\\\">// sepBy gives us a list, so we have to pick the parts out</span>\\n  shorts =&gt;\\n    <span class=\\\"hljs-keyword\\\">switch</span> (shorts) {\\n    | [a, b, <span class=\\\"hljs-built_in\\\">c</span>, d] =&gt;\\n      <span class=\\\"hljs-comment\\\">// Use pure here because we need to wrap the result in a parser to satisfy</span>\\n      <span class=\\\"hljs-comment\\\">// the type signature of the &gt;&gt;= function</span>\\n      pure(make(a, b, <span class=\\\"hljs-built_in\\\">c</span>, d))\\n    | <span class=\\\"hljs-number\\\">_</span> =&gt; fail(<span class=\\\"hljs-string\\\">\\\"Expected exactly 4 shorts separated by .\\\"</span>)\\n           <span class=\\\"hljs-comment\\\">// fail produces a `Parser.t(_)` that will always fail</span>\\n    }\\n)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>)</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">2553</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>See the code and tests for more examples.</p>\\n<h1 id=\\\"api-documentation\\\"><a href=\\\"#api-documentation\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>API Documentation</h1>\\n<p>For more details, examples, tests, etc., please refer to the code.  Below is a possibly incomplete\\nlist of parser functions that come with <code>ReludeParse</code>.</p>\\n<h2 id=\\\"basic-operations\\\"><a href=\\\"#basic-operations\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Basic operations</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>runParser</code></td>\\n<td>runs a parser with an input string to produce a \\n<code>Belt.Result</code>\\n with either the value or a \\n<code>ParseError.t</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>unParser</code></td>\\n<td>runs a parser with an input string to produce a \\n<code>Belt.Result</code>\\n with either the value or a \\n<code>ParseError.t</code>\\n (with some additional metadata compared to \\n<code>runParser</code>\\n)</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"core-fp-functions-and-operators\\\"><a href=\\\"#core-fp-functions-and-operators\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Core FP functions and operators</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>map</code>\\n/\\n<code>&#x3C;$></code>\\n/\\n<code>&#x3C;#></code>\\n/\\n<code>&#x3C;$</code>\\n/\\n<code>$></code></td>\\n<td>functor functions for mapping pure functions over a parser</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>apply</code>\\n/\\n<code>&#x3C;*></code>\\n/\\n<code>&#x3C;*</code>\\n/\\n<code>*></code></td>\\n<td>applicative functions for combining parsers</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>&#x3C;^></code></td>\\n<td>combine two parsers to produce a tuple of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>tuple2</code>\\n-\\n<code>5</code></td>\\n<td>combine parsers to produce tuples of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>map2</code>\\n-\\n<code>5</code></td>\\n<td>combine parsers using a function to combine the results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>mapTuple2</code>\\n-\\n<code>5</code></td>\\n<td>combine a tuple of parsers using a function to combine the results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>pure</code></td>\\n<td>lift a pure value into a parser that always succeeds with the value</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>unit</code></td>\\n<td>lift a pure \\n<code>()</code>\\n value into a parser that always succeeds with \\n<code>()</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>flatMap</code>\\n/\\n<code>bind</code>\\n/\\n<code>>>=</code></td>\\n<td>map a function over a parser that can produce a new parser - used for sequencing parsers</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<p><strong>Parsers also get all of the additional utilities provided by all the <code>Relude</code> typeclass extensions.</strong></p>\\n<h2 id=\\\"loggingside-effects\\\"><a href=\\\"#loggingside-effects\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Logging/side effects</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>tap</code></td>\\n<td>runs a side effect function in a parse change, and forwards the given result along</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>tapLog</code></td>\\n<td>logs some information about the current parse position</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"error-customizationhandling\\\"><a href=\\\"#error-customizationhandling\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Error customization/handling</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>withError</code>\\n/\\n<code>flipWithError</code>\\n/\\n<code>&#x3C;?></code></td>\\n<td>provide a custom error message</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>throwError</code></td>\\n<td>Create a parser that fails with the given \\n<code>ParseError.t</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>fail</code></td>\\n<td>Create a parser that fails with the given \\n<code>string</code>\\n message</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>catchError</code></td>\\n<td>Handle a failed parse by converting a \\n<code>ParseError.t</code>\\n into a new parser</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"repeated-values\\\"><a href=\\\"#repeated-values\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Repeated values</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>many</code></td>\\n<td>Run any parser 0 or more times to produce a \\n<code>[]</code>\\n of values (like \\n<code>*</code>\\n in regex)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1</code></td>\\n<td>Run any parser 1 or more times to produce a \\n<code>Relude.NonEmptyList</code>\\n (aka \\n<code>Nel</code>\\n) of values (like \\n<code>+</code>\\n in regex) - the result is a \\n<code>Nel</code>\\n because we are guaranteed to find at least one value, otherwise the parser will fail</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>times</code></td>\\n<td>run a parser \\n<code>count</code>\\n times and produce a \\n<code>[]</code>\\n of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>times2</code>\\n-\\n<code>5</code></td>\\n<td>run a parser exactly twice (up to 5) to produce a tuple of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>timesMin</code></td>\\n<td>run a parser at least n times to produce a list of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>timesMax</code></td>\\n<td>run a parser at most n times to produce a list of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>timesMinMax</code></td>\\n<td>run a parser at least n times and at most m times to produce a list of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntilWithEnd</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1UntilWithEnd</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntil</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and discarding the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1Until</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and discarding the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntilPeekWithEnd</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1UntilPeekWithEnd</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntilPeek</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and discarding the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1UntilPeek</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and discarding the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"optionaldefault-values\\\"><a href=\\\"#optionaldefault-values\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Optional/default values</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>opt</code></td>\\n<td>attempt a parser, and wrap a success in \\n<code>Some</code>\\n and convert a failure to \\n<code>None</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orDefault</code></td>\\n<td>attempt a parser, and if it fails, produce a default value</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orUnit</code></td>\\n<td>attempt a parser, and if it fails, produce unit</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"delimited-values\\\"><a href=\\\"#delimited-values\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Delimited values</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>between</code></td>\\n<td>parse a value inside opening and closing delimiters</td>\\n<td><code>(abc)</code></td>\\n</tr>\\n<tr>\\n<td><code>sepBy</code></td>\\n<td>parse zero or more values separated by a delimiter</td>\\n<td><code>a,b,c,d</code></td>\\n</tr>\\n<tr>\\n<td><code>sepBy1</code></td>\\n<td>parse one or more values separated by a delimiter</td>\\n<td><code>a,b,c,d</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByOptEnd</code></td>\\n<td>parse zero or more values separated by a delimiter, optionally ending with the delimiter</td>\\n<td><code>a,b,c,d</code>\\n or \\n<code>a,b,c,d,</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByOptEnd1</code></td>\\n<td>parse one or more values separated by a delimiter, optionally ending with the delimiter</td>\\n<td><code>a,b,c,d</code>\\n or \\n<code>a,b,c,d,</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByWithEnd</code></td>\\n<td>parse zero or more delimited values ending with the delimiter</td>\\n<td><code>a,b,c,</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByWithEnd1</code></td>\\n<td>parse one or more delimited values ending with the delimiter</td>\\n<td><code>a,b,c,</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"associative-operators\\\"><a href=\\\"#associative-operators\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Associative operators</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>chainr1</code></td>\\n<td>parse values separated by a right-associative operator (useful for parsing math expressions)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>chainl1</code></td>\\n<td>parse values separated by a left-associative operator (useful for parsing math expressions)</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"trying-different-parsers\\\"><a href=\\\"#trying-different-parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Trying different parsers</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>tries</code></td>\\n<td>Tries a parser, and backtracks all the way to the original start position for the parser on failure.  This is useful if you are using a more complex parser that might consume some input successfully before it fails.  The default behavior is to only backtrack to the start of the failure, whereas this function forces the parse to backtrack to the beginning of the complex parser's input.</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>alt</code>\\n/\\n<code>altLazy</code>\\n/\\n<code>orElse</code>\\n/\\n<code>orElseLazy</code>\\n/\\n<code>&#x3C;pipe></code></td>\\n<td>try a parser, and if it fails, try the other</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyOf</code></td>\\n<td>Attempts to parse a value using a list of potential parsers, tried from left to right</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"validationextraction\\\"><a href=\\\"#validationextraction\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Validation/extraction</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>lookAhead</code>\\n/\\n<code>peek</code></td>\\n<td>Run a parser to produce a value, without consuming any input</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>lookAheadNot</code>\\n/\\n<code>peekNot</code></td>\\n<td>Run a parser which fails if it produces a value, without consuming any input</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>filter</code></td>\\n<td>apply a predicate to the result of a parser to either continue or fail the parse</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getSome</code></td>\\n<td>converts a parser of \\n<code>option('a)</code>\\n into a parser of \\n<code>'a</code>\\n, failing if the value is \\n<code>None</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getNonEmptyStr</code></td>\\n<td>converts a parser of \\n<code>string</code>\\n into a parser of a non-empty \\n<code>string</code>\\n, failing if the value is \\n<code>\\\"\\\"</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getFst</code></td>\\n<td>converts a parser of \\n<code>('a, 'b)</code>\\n into a parser of \\n<code>'a</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getSnd</code></td>\\n<td>converts a parser of \\n<code>('a, 'b)</code>\\n into a parser of \\n<code>'b</code></td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"text-parsers\\\"><a href=\\\"#text-parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Text parsers</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>eof</code></td>\\n<td>verify that the end of the input has been reached</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orEOF</code></td>\\n<td>attempts a parser, and throws away the result, or if it fails, attempts the \\n<code>eof</code>\\n parser</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyChar</code></td>\\n<td>parses any single character</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>notChar</code></td>\\n<td>parses any single character except the given</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyStr</code></td>\\n<td>parses any string (WARNING: this will likely consume all remaining input)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonEmptyStr</code></td>\\n<td>parses any non-empty (\\n<code>\\\"\\\"</code>\\n) string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>str</code></td>\\n<td>parses the given string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>strIgnoreCase</code></td>\\n<td>parses the given string case-insensitively</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharBy</code></td>\\n<td>parses a character, and checks it with a predicate function</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyOfStr</code></td>\\n<td>parses any of the given strings</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyOfStrIgnoreCase</code></td>\\n<td>parses any of the given strings case insensitively</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>wsList</code></td>\\n<td>parses any amount of whitespace characters and returns them in a list of single chars</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>wsString</code></td>\\n<td>parses any amount of whitespace characters and returns them in a string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>ws</code></td>\\n<td>parses any amount of whitespace characters throws them away (produces \\n<code>()</code>\\n)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharNotIn</code></td>\\n<td>parses any single char not in the given list</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharNotInIgnoreCase</code></td>\\n<td>parses any single char not in the given list, case-insensitive</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharInRange</code></td>\\n<td>parses any character in the ASCII code range</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonDigit</code></td>\\n<td>parses any non-digit character</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyLowerCaseChar</code></td>\\n<td>parses a single lowercase letter char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyUpperCaseChar</code></td>\\n<td>parses a single uppercase letter char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyAlpha</code></td>\\n<td>parses any upper or lowercase letter char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyAlphaOrDigit</code></td>\\n<td>parses any upper or lowercase letter or digit char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>regex</code></td>\\n<td>parses a string matching the given regex</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>regexStr</code></td>\\n<td>parses a string matching the given regex string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftParen</code></td>\\n<td>parses a \\n<code>(</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightParen</code></td>\\n<td>parses a \\n<code>)</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenParens</code></td>\\n<td>parses a value inside \\n<code>(</code>\\n and \\n<code>)</code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftCurly</code></td>\\n<td>parses a \\n<code>{</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightCurly</code></td>\\n<td>parses a \\n<code>}</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenCurlies</code></td>\\n<td>parses a value inside \\n<code>{</code>\\n and \\n<code>}</code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftSquare</code></td>\\n<td>parses a \\n<code>[</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightSquare</code></td>\\n<td>parses a \\n<code>]</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenSquares</code></td>\\n<td>parses a value inside \\n<code>[</code>\\n and \\n<code>]</code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftAngle</code></td>\\n<td>parses a \\n<code>&#x3C;</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightAngle</code></td>\\n<td>parses a \\n<code>></code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenAngles</code></td>\\n<td>parses a value inside \\n<code>&#x3C;</code>\\n and \\n<code>></code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>singleQuote</code></td>\\n<td>parses a \\n<code>'</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenSingleQuotes</code></td>\\n<td>parses a value inside \\n<code>'</code>\\n and \\n<code>'</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>doubleQuote</code></td>\\n<td>parses a \\n<code>'</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenDoubleQuotes</code></td>\\n<td>parses a value inside \\n<code>\\\"</code>\\n and \\n<code>\\\"</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>backTick</code></td>\\n<td>parses a backtick</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenBackTicks</code></td>\\n<td>parses a value inside backticks</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>cr</code></td>\\n<td>parses a \\n<code>\\\\r</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>lf</code></td>\\n<td>parses a \\n<code>\\\\n</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>crlf</code></td>\\n<td>parses a \\n<code>\\\\r\\\\n</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>eol</code></td>\\n<td>parses a \\n<code>\\\\r\\\\n</code>\\n, \\n<code>\\\\r</code>\\n, or a \\n<code>\\\\n</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orEOL</code></td>\\n<td>runs a parser and discards the result, or if it fails, try the \\n<code>eol</code>\\n parser</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"numeric-parsers\\\"><a href=\\\"#numeric-parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Numeric parsers</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>anyDigit</code></td>\\n<td>parses any single character, makes sure it's a digit 0-9 and produces it as a single character string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyDigitAsInt</code></td>\\n<td>parses any single character, makes sure it's a digit 0-9 and converts it to an int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonEmptyDigits</code></td>\\n<td>parses 1 or more consecutive digits as a string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonZeroDigit</code></td>\\n<td>parses any non-zero digit character</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonZeroDigitAsInt</code></td>\\n<td>parses any non-zero digit character as an int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyUnsignedInt</code></td>\\n<td>parses an integer with no \\n<code>+</code>\\n or \\n<code>-</code>\\n prefix</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyPositiveInt</code></td>\\n<td>parses a positive integer (optional + prefix)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNegativeInt</code></td>\\n<td>parses a negative integer (- prefix)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyInt</code></td>\\n<td>parses any positive or negative int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyUnsignedShort</code></td>\\n<td>parses a short int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyDecimal</code></td>\\n<td>parses a decimal value with optional exponential notation</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyHexDigit</code></td>\\n<td>parses any hex digit 0-9 or a-f or A-F</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonZeroHexDigit</code></td>\\n<td>parses any hex digit 1-9 or a-f or A-F</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyBool</code></td>\\n<td>parses a bool true or false value</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>See the code and tests for a complete list of functions and examples.</p>\\n<h1 id=\\\"extra-utilities\\\"><a href=\\\"#extra-utilities\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Extra Utilities</h1>\\n<p><code>ReludeParse</code> comes with a few higher-level parsers for convenience and for educational\\npurposes.</p>\\n<ul>\\n<li><code>ReludeParse.IPv4</code> - IPv4 addresses</li>\\n<li><code>ReludeParse.IPv6</code> - IPv6 addresses</li>\\n<li><code>ReludeParse.UUID</code> - 8-4-4-4-12 UUIDs</li>\\n<li><code>ReludeParse.NanpPhone</code> - North American Numbering Plan (NANP) phone numbers</li>\\n</ul>\\n<p>Other parsers and utilities for things like <code>URL</code>s and <code>DateTime</code>s can be found in other libraries like\\n<a href=\\\"https://github.com/reazen/relude-url\\\">relude-url</a> and <a href=\\\"https://github.com/reazen/relude-eon\\\">relude-eon</a>.</p>\\n\",\"homepageUrl\":\"https://github.com/reazen/relude-parse#readme\",\"repositoryUrl\":\"https://github.com/reazen/relude-parse\",\"npmUrl\":\"https://www.npmjs.com/package/relude-parse\",\"issuesUrl\":\"https://github.com/reazen/relude-parse/issues\",\"slug\":\"/package/relude-parse\"}},\"pathContext\":{\"id\":\"relude-parse\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---package-relude-parse-5a52309f25381373922c.js","module.exports = {\"data\":{\"package\":{\"type\":\"published\",\"id\":\"relude-parse\",\"name\":\"relude-parse\",\"version\":\"0.8.0\",\"category\":\"library\",\"flags\":[],\"platforms\":[\"browser\",\"node\"],\"description\":\"Monadic parsing with Relude\",\"keywords\":[\"parsing\"],\"license\":\"MIT\",\"updated\":\"2020-06-26T21:15:46.337Z\",\"stars\":26,\"score\":0.6113400696511464,\"quality\":0.8456689416111867,\"popularity\":0.05010231773469999,\"maintenance\":0.9717245027447012,\"readme\":\"<h1 id=\\\"relude-parse\\\"><a href=\\\"#relude-parse\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>relude-parse</h1>\\n<p><a href=\\\"https://github.com/reazen/relude-parse/actions\\\"><img src=\\\"https://img.shields.io/github/workflow/status/reazen/relude-parse/CI/master\\\" alt=\\\"GitHub CI\\\"></a>\\n<a href=\\\"https://www.npmjs.com/package/relude-parse\\\"><img src=\\\"https://img.shields.io/npm/v/relude-parse.svg\\\" alt=\\\"npm\\\"></a></p>\\n<h1 id=\\\"overview\\\"><a href=\\\"#overview\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Overview</h1>\\n<p><code>ReludeParse</code> is a pure-functional string parsing library for\\nReasonML/Bucklescript, built on top of the functional programming types and\\ntype classes provided by <a href=\\\"https://github.com/reazen/relude\\\">Relude</a>.</p>\\n<p><code>ReludeParse</code> was influenced by <a href=\\\"https://github.com/purescript-contrib/purescript-string-parsers\\\">purescript-string-parsers</a>, <a href=\\\"https://github.com/deathbeam/parsihax\\\">parsihax</a>, and <a href=\\\"https://github.com/tpolecat/atto\\\">atto</a>, and several of the parsers in the Haskell ecosystem.</p>\\n<h1 id=\\\"getting-started\\\"><a href=\\\"#getting-started\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Getting started</h1>\\n<h2 id=\\\"install-the-library\\\"><a href=\\\"#install-the-library\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Install the library</h2>\\n<div class=\\\"redex-codeblock\\\"><pre class=\\\"hljs lang-bash\\\"><code>// Install the library from npm\\nnpm install --save-dev relude relude-parse\\n// add relude and relude-parse to your bsconfig.json</code></pre></div>\\n<h2 id=\\\"import-the-types-functions-operators-etc\\\"><a href=\\\"#import-the-types-functions-operators-etc\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Import the types, functions, operators, etc.</h2>\\n<p><code>ReludeParse</code> is the root namespace module.</p>\\n<p>In ReasonML/Bucklescript, you can get access to a module's functions in a variety of ways, here\\nare a few examples:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Method 1: Global open (not recommended)</span>\\nopen <span class=\\\"hljs-type\\\">ReludeParse</span>.<span class=\\\"hljs-type\\\">Parser</span>;\\n<span class=\\\"hljs-keyword\\\">let</span> <span class=\\\"hljs-number\\\">_</span> = anyDigit &lt;* eof |&gt; runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// Method 2: Local open (good but more verbose)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> <span class=\\\"hljs-number\\\">_</span> = <span class=\\\"hljs-type\\\">ReludeParse</span>.<span class=\\\"hljs-type\\\">Parser</span>.(anyDigit &lt;* eof |&gt; runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>));\\n\\n<span class=\\\"hljs-comment\\\">// Method 3: Module alias with small global open (tradeoff between 1 and 2 above)</span>\\n<span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">module</span> <span class=\\\"hljs-title\\\">P</span> = <span class=\\\"hljs-title\\\">ReludeParse</span>.<span class=\\\"hljs-title\\\">Parser</span>;\\n<span class=\\\"hljs-title\\\">open</span> <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">Infix</span>; // <span class=\\\"hljs-title\\\">Get</span> <span class=\\\"hljs-title\\\">all</span> <span class=\\\"hljs-title\\\">the</span> <span class=\\\"hljs-title\\\">infix</span> <span class=\\\"hljs-title\\\">operators</span> <span class=\\\"hljs-title\\\">in</span> <span class=\\\"hljs-title\\\">scope</span>\\n<span class=\\\"hljs-title\\\">let</span> <span class=\\\"hljs-title\\\">_</span> = <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">anyDigit</span> &lt;* <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">eof</span> |&gt; <span class=\\\"hljs-title\\\">P</span>.<span class=\\\"hljs-title\\\">runParser</span>(\\\"1\\\");</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>I recommend using method 3 for most cases, but if you are running into conflicts, use method 2.\\nIf you just want to live your life, use method 1.</p>\\n<p>For examples below, I'm going to assume method 3.</p>\\n<p>As a side note, the relude ecosystem prefers the <code>|></code> pipe operator over <code>-></code>, so most\\nfunctions are \\\"significant data last\\\" style, and the \\\"significant data\\\" is typically\\na value of type <code>Parser.t('a)</code>.  This allows you to do things like:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.sepBy(str(<span class=\\\"hljs-string\\\">\\\",\\\"</span>))</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ = <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; (<span class=\\\"hljs-type\\\">P</span>.sepBy (str <span class=\\\"hljs-string\\\">\\\",\\\"</span>))</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>which is the same as below:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.sepBy(str(<span class=\\\"hljs-string\\\">\\\",\\\"</span>), <span class=\\\"hljs-type\\\">P</span>.anyAlpha)</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ = <span class=\\\"hljs-type\\\">P</span>.sepBy (str <span class=\\\"hljs-string\\\">\\\",\\\"</span>) <span class=\\\"hljs-type\\\">P</span>.anyAlpha</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Luckily, either way is perfectly legit, so use whichever style you prefer.</p>\\n<h1 id=\\\"parsers\\\"><a href=\\\"#parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Parsers</h1>\\n<p><code>ReludeParse.Parser.t('a)</code> is a data type which encapsulates the ability to parse a string\\ninto a value of type <code>'a</code>, or fail with a fixed <code>ParseError.t</code> type, which provides an error message and parse position.</p>\\n<p><code>ReludeParse</code> provides a wide variety of low-level, medium-level, and\\nhigh-level parsers which can be composed together to parse just about\\nanything.  Note that there are a few functions (like <code>many</code>) that are not stack safe,\\nso beware when parsing very large strings of repeating characters.  Someday these functions\\nmaybe become stack safe.</p>\\n<p>The parse errors are currently pretty minimal only giving an error message and parse position.\\nSomeday this may improve.</p>\\n<h1 id=\\\"run-a-parser\\\"><a href=\\\"#run-a-parser\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Run a parser</h1>\\n<p>A parser will attempt to consume input from a string until it can successfully finish and produce\\na value or fail.  The parser will only consume enough of the string to satisfy\\nits own parsing needs (whatever it needs to produce the final value), and will leave the rest of the string for the next parser (if any).</p>\\n<p>To run a parser, simply pipe (or pass) it into the <code>P.runParser</code> function, along with the input string:</p>\\n<p>Success example:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// anyDigit will attempt to consume a single character, and succeeds if that character</span>\\n<span class=\\\"hljs-comment\\\">// is a digit 0-9</span>\\n\\n<span class=\\\"hljs-comment\\\">// Pipe operator |&gt;</span>\\n\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"1\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// Or normal function application</span>\\n\\n<span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>, <span class=\\\"hljs-type\\\">P</span>.anyDigit)</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Failure example:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"!\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(ParseError(\\\"Expected a digit\\\"))</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code>let _ =\\n  P.anyDigit |&gt;\\n    ((P.runParser \\\"!\\\") //\\n       ((Belt.Result.Error\\n           (((ParseError (\\\"Expected a digit\\\"))[@explicit_arity ])))[@explicit_arity\\n                                                                    ]))</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>In the event of a failed parse, parsers will (in most cases) back-track so that an alternative\\nparser (if supplied) can pick-up where the previous failed.</p>\\n<p>There is also a <code>P.unParser</code> function, which gives you access to more of the internals\\nin the event of success or failure.  It's called <code>unParser</code> because it unwraps or \\\"lowers\\\" a\\nvalue of type <code>Parser.t('a)</code> to the raw parsing function contained within.</p>\\n<h1 id=\\\"mapping-a-function-over-a-parser\\\"><a href=\\\"#mapping-a-function-over-a-parser\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Mapping a function over a parser</h1>\\n<p>A <code>RelueParse.Parser</code> is a <code>functor</code>, so we can map a pure function over the parser's value.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Warning: int_of_string is unsafe (can throw) - this is just an example</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.<span class=\\\"hljs-built_in\\\">map</span>(int_of_string) |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(1)</span>\\n\\n<span class=\\\"hljs-comment\\\">// &lt;$&gt; map operator version.  &lt;$&gt; is traditionally \\\"function on the left\\\"</span>\\nint_of_string &lt;$&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// &lt;#&gt; flipped map operator version - &lt;#&gt; is function on the right hand side,</span>\\n<span class=\\\"hljs-comment\\\">// which might be more readable for some.</span>\\n<span class=\\\"hljs-comment\\\">// When you see `&lt;#&gt;` just think `.map(...)` from JavaScript</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;#&gt; int_of_string |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"1\\\"</span>);</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Note: see the monad section for an information on how to handle or produce errors while parsing.</p>\\n<p><code>Parser.t('a)</code> comes with all the bells and whistles that are granted to all\\n<code>functors</code> in relude. This includes:</p>\\n<ul>\\n<li>the <code>map</code> function</li>\\n<li>the <code>&#x3C;$></code> (<code>map</code>) operator</li>\\n<li><code>flipMap</code></li>\\n<li>the <code>&#x3C;#></code> (<code>flipMap</code>) operator</li>\\n<li>the <code>&#x3C;$</code> operator</li>\\n<li>the <code>$></code> operator</li>\\n</ul>\\n<p>These things are all provided \\\"for free\\\" via the <a href=\\\"https://github.com/reazen/relude/blob/master/src/extensions/Relude_Extensions_Functor.re\\\">Relude Functor Extensions</a></p>\\n<p>Note: <code>Parser.t('a)</code> is not a bi-functor - the error type is fixed to\\na known data type for simplicity.</p>\\n<h1 id=\\\"combining-parsers-via-applicative\\\"><a href=\\\"#combining-parsers-via-applicative\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Combining parsers (via Applicative)</h1>\\n<p>A <code>ReludeParse.Parser.t('a)</code> is an <code>applicative functor</code>, so we can combine multiple parsers\\ntogether using a variety of techniques.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Combine two parsers into a tuple of the results (assuming all succeed)</span>\\n<span class=\\\"hljs-type\\\">P</span>.tuple2(<span class=\\\"hljs-type\\\">P</span>.anyDigit, <span class=\\\"hljs-type\\\">P</span>.anyDigit) |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok((\\\"1\\\", \\\"2\\\"))</span>\\n\\n<span class=\\\"hljs-comment\\\">// &lt;^&gt; operator (operator version of tuple2)</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;^&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok((\\\"1\\\", \\\"2\\\"))</span>\\n\\n<span class=\\\"hljs-comment\\\">// Combine more parsers using tuple3 up to tuple5</span>\\n<span class=\\\"hljs-type\\\">P</span>.tuple3(<span class=\\\"hljs-type\\\">P</span>.anyDigit, <span class=\\\"hljs-type\\\">P</span>.anyDigit, <span class=\\\"hljs-type\\\">P</span>.anyDigit)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"123\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok((\\\"1\\\", \\\"2\\\", \\\"3\\\"))</span>\\n\\n<span class=\\\"hljs-comment\\\">// Combine parse results using a function via map2 through map5</span>\\n<span class=\\\"hljs-type\\\">P</span>.map2((a, b) =&gt; a + b, <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt, <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(3)</span>\\n\\n<span class=\\\"hljs-comment\\\">// Combine results from a tuple of parsers using mapTuple2 through mapTuple5</span>\\n(<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt, <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.mapTuple2((a, b) =&gt; a + b)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"12\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(3)</span>\\n\\n<span class=\\\"hljs-comment\\\">// Use the *&gt; operator to run two parsers, and only keep the result from the right side</span>\\n<span class=\\\"hljs-comment\\\">// This is useful if you don't care what the left side parser produces (e.g. whitespace)</span>\\n<span class=\\\"hljs-comment\\\">// but you need to consume that input.</span>\\n<span class=\\\"hljs-comment\\\">// `ws` consumes all the whitespace it encounters and throws it away</span>\\n<span class=\\\"hljs-type\\\">P</span>.ws\\n*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"   3\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"3\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// Use the &lt;* operator to run two parsers, and only keep the result from the left side</span>\\n<span class=\\\"hljs-comment\\\">// This is useful if you don't care what the right side parser produces (e.g. whitespace)</span>\\n<span class=\\\"hljs-comment\\\">// but you want to consume that input.</span>\\n<span class=\\\"hljs-comment\\\">// It's common to use this operator with `eof` to make sure you've hit the end of the input</span>\\n<span class=\\\"hljs-comment\\\">// (but you don't care about the value produced by `eof`).</span>\\n<span class=\\\"hljs-comment\\\">// E.g. use both *&gt; and &lt;* to trim whitespace surrounding a value</span>\\n<span class=\\\"hljs-type\\\">P</span>.ws\\n*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit\\n&lt;* <span class=\\\"hljs-type\\\">P</span>.ws\\n&lt;* <span class=\\\"hljs-type\\\">P</span>.eof\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"   3  \\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"3\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// ADVANCED: Incrementally collect parse results using a function and chained &lt;$&gt; map and &lt;*&gt; apply</span>\\n<span class=\\\"hljs-comment\\\">// operators.</span>\\n<span class=\\\"hljs-keyword\\\">let</span> add3 = (a, b, <span class=\\\"hljs-built_in\\\">c</span>) =&gt; a + b + <span class=\\\"hljs-built_in\\\">c</span>;\\nadd3\\n&lt;$&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&lt;*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&lt;*&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"123\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(6)</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Many of these functions and operators come for free for any Applicative via <a href=\\\"https://github.com/reazen/relude/blob/master/src/extensions/Relude_Extensions_Apply.re\\\">Relude Apply Extensions</a></p>\\n<h1 id=\\\"sequencing-parsers-via-monads\\\"><a href=\\\"#sequencing-parsers-via-monads\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Sequencing parsers (via Monads)</h1>\\n<p>A <code>Parser.t('a)</code> is also a <code>monad</code>, so you can put pure values directly into a parser using <code>pure</code>,\\nand more importantly, you can sequence parsers using <code>flatMap</code>, <code>bind</code>, or the <code>>>=</code> operator.\\n<code>bind</code>, <code>flatMap</code> and <code>>>=</code> all basically do the same thing - the take a <code>Parser.t('a)</code>, a function from <code>'a => Parser.t('b)</code> and give you a <code>Parser.t('b)</code>.  What this basically means is that you can \\\"run\\\" a parser to\\nproduce a value (note: I don't mean return a value, but produce a value inside your monadic flow), then use that value to create a new parser with which to continue processing.  Note that you can't do that with the functors and applicative-based parsing, because <code>map</code>/<code>apply</code>/<code>&#x3C;*></code> and friends don't give you the opportunity to produce a new parser based on the value - you can only apply functions inside the context of a parser.</p>\\n<p>For intuition, <code>flatMap</code> is an apt name for this function because if you have a <code>myToOfA: t('a)</code>, a function <code>aToTOfB: 'a => t('b)</code>, and you do <code>myTOfA |> map(aToTOfB)</code> you'll get a <code>t(t('b))</code>.  A monad has the ability to \\\"flatten\\\" itself when in a nested structure like this, i.e. <code>flatten: t(t('b)) => t('b)</code>.  In some languages <code>flatten</code> is often named <code>join</code> - like you are flattening or joining a nested structure into a single structure.  <code>flatMap</code> can be implemented in terms of <code>map</code> and <code>flatten</code>, and flatten can be implmeented in terms of <code>flatMap</code>.</p>\\n<p>So <code>flatMap</code> is mapping a monadic function <code>'a => t('b)</code> over a <code>t('a)</code>, and then flattening the resulting <code>t(t('b))</code> to just <code>t('b)</code>.</p>\\n<p>The true power of monads is the ability to produce a new monadic value (i.e. a new parser) mid-flow, which can be used for producing and handling errors, or forking the parse flow to do something different, based on what you've previously parsed.</p>\\n<p>Note that monads have \\\"fail-fast\\\" semantics, because if a parser fails to produce a value, it's\\nnot possible for the next parser to accept a value (because there is none).  In other words,\\nif a parser fails at some point in a chain, the rest of the parsers will not run.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Lift a pure value into a parser.</span>\\n<span class=\\\"hljs-comment\\\">// As you can see the parser just produces the given value regardless of the string.</span>\\n<span class=\\\"hljs-type\\\">P</span>.pure(<span class=\\\"hljs-number\\\">3</span>)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"abcdef\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(3)</span>\\n\\n<span class=\\\"hljs-comment\\\">// Sequence parse operations using flatMap.</span>\\n<span class=\\\"hljs-comment\\\">// In this example we read a single digit as an int, then use that value</span>\\n<span class=\\\"hljs-comment\\\">// to read a series of letters, and expect to consume the whole input.</span>\\n<span class=\\\"hljs-comment\\\">// This is sequencing because we use the result of one parser to determine</span>\\n<span class=\\\"hljs-comment\\\">// the next parser to run.</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.flatMap(<span class=\\\"hljs-built_in\\\">count</span> =&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.times(<span class=\\\"hljs-built_in\\\">count</span>) &lt;* <span class=\\\"hljs-type\\\">P</span>.eof)\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.<span class=\\\"hljs-built_in\\\">map</span>(chars =&gt; <span class=\\\"hljs-type\\\">Relude</span>.<span class=\\\"hljs-type\\\">List</span>.<span class=\\\"hljs-type\\\">String</span>.<span class=\\\"hljs-built_in\\\">join</span>(chars))\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"3abc\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"abc\\\")</span>\\n\\n<span class=\\\"hljs-comment\\\">// Sequence using &gt;&gt;= (flatMap/bind) and &lt;#&gt; (map) operators.</span>\\n<span class=\\\"hljs-comment\\\">// If you are coming from JS -</span>\\n<span class=\\\"hljs-comment\\\">// Don't be afraid of the operators - when you see &gt;&gt;= read \\\".flatMap(...)\\\"</span>\\n<span class=\\\"hljs-comment\\\">// and when you see \\\"&lt;#&gt;\\\" read \\\".map(...)\\\".  Eventually these will become</span>\\n<span class=\\\"hljs-comment\\\">// second nature.</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&gt;&gt;= (<span class=\\\"hljs-built_in\\\">count</span> =&gt; <span class=\\\"hljs-type\\\">P</span>.times(<span class=\\\"hljs-built_in\\\">count</span>, <span class=\\\"hljs-type\\\">P</span>.anyAlpha) &lt;* <span class=\\\"hljs-type\\\">P</span>.eof)\\n&lt;#&gt; <span class=\\\"hljs-type\\\">Relude</span>.<span class=\\\"hljs-type\\\">List</span>.<span class=\\\"hljs-type\\\">String</span>.<span class=\\\"hljs-built_in\\\">join</span>\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"3abc\\\"</span>); <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"abc\\\")</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Many of these functions come for free for any Monad via <a href=\\\"https://github.com/reazen/relude/blob/master/src/extensions/Relude_Extensions_Monad.re\\\">Relude Monad Extensions</a></p>\\n<h1 id=\\\"add-validation-and-error-handling-in-a-parse-chain\\\"><a href=\\\"#add-validation-and-error-handling-in-a-parse-chain\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Add validation and error handling in a parse chain</h1>\\n<p>You can also use the monadic behavior to optionally fail a parse inside a\\n<code>bind</code>/<code>flatMap</code>/<code>>>=</code> function.  Note that you can't fail a parse inside a <code>map</code>\\nbecause map uses a pure function from <code>'a => 'b</code>, so there's no way to indicate failure\\nof the parse - you are only allowed to produce a new value <code>'b</code> <em>inside</em> the context of an existing\\nparser.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n&gt;&gt;= (\\n  <span class=\\\"hljs-built_in\\\">count</span> =&gt;\\n    <span class=\\\"hljs-keyword\\\">if</span> (<span class=\\\"hljs-built_in\\\">count</span> &gt;= <span class=\\\"hljs-number\\\">5</span>) {\\n      <span class=\\\"hljs-comment\\\">// P.fail is a parser that always fails with the given message</span>\\n      <span class=\\\"hljs-comment\\\">// just like P.pure always succeeds with the given value.</span>\\n      <span class=\\\"hljs-comment\\\">// Using &gt;&gt;= and fail is a common way to inject validations and raise errors.</span>\\n      <span class=\\\"hljs-type\\\">P</span>.fail(<span class=\\\"hljs-string\\\">\\\"The count cannot be &gt;= 5\\\"</span>);\\n    } <span class=\\\"hljs-keyword\\\">else</span> {\\n      <span class=\\\"hljs-comment\\\">// Now that we have a valid count, carry on</span>\\n      <span class=\\\"hljs-type\\\">P</span>.times(<span class=\\\"hljs-built_in\\\">count</span>, <span class=\\\"hljs-type\\\">P</span>.anyAlpha) &lt;* eof;\\n    }\\n)\\n&lt;#&gt; <span class=\\\"hljs-type\\\">Relude</span>.<span class=\\\"hljs-type\\\">List</span>.<span class=\\\"hljs-type\\\">String</span>.<span class=\\\"hljs-built_in\\\">join</span>\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"9abc\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(ParseError(\\\"The count cannot be &gt;= 5\\\"))</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">3321</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>The <code>filter</code> function in <code>ReludeParse</code> is basically for this purpose.  Filter produces its\\nown generic error message if the predicate fails, but you can customize it like below:</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.<span class=\\\"hljs-built_in\\\">filter</span>(a =&gt; a &gt; <span class=\\\"hljs-number\\\">5</span>)\\n&lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected an int greater than 5\\\"</span>;</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ =\\n  (<span class=\\\"hljs-type\\\">P</span>.anyDigitAsInt |&gt; (<span class=\\\"hljs-type\\\">P</span>.filter (<span class=\\\"hljs-keyword\\\">fun</span> a  -&gt; a &gt; <span class=\\\"hljs-number\\\">5</span>))) &lt;?&gt;\\n    <span class=\\\"hljs-string\\\">\\\"Expected an int greater than 5\\\"</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"trying-multiple-parsers-via-alt\\\"><a href=\\\"#trying-multiple-parsers-via-alt\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Trying multiple parsers (via Alt)</h1>\\n<p><code>ReludeParse.Parser.t('a)</code> is also an <code>alt</code> functor, which means you can try one parser, and\\nif it fails, try another, as many times as you want.</p>\\n<p>The <code>&#x3C;|></code> operator is used for this - think of the <code>&#x3C;|></code> operator as an <code>orElse</code> function.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"9\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"9\\\")</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"a\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"a\\\")</span>\\n<span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha |&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"!\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(...)</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">967</span>: syntax error, consider adding a `;<span class=\\\"hljs-char\\\">' before</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<p><code>&#x3C;|></code> can be chained as many times as you want - it attempts each parser left-to-right.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"a\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"b\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"c\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"d\\\"</span>) ...and so on</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">967</span>: syntax error, consider adding a `;<span class=\\\"hljs-char\\\">' before</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<p>If none of the parsers succeed, it will return the error of the last parser, so a common\\ntechnique is to use <code>&#x3C;?></code> to add a custom error message at the end</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"a\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"b\\\"</span>) &lt;|&gt; <span class=\\\"hljs-type\\\">P</span>.str(<span class=\\\"hljs-string\\\">\\\"c\\\"</span>) &lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected a, b, or c\\\"</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> _ =\\n  (((<span class=\\\"hljs-type\\\">P</span>.str <span class=\\\"hljs-string\\\">\\\"a\\\"</span>) &lt;|&gt; (<span class=\\\"hljs-type\\\">P</span>.str <span class=\\\"hljs-string\\\">\\\"b\\\"</span>)) &lt;|&gt; (<span class=\\\"hljs-type\\\">P</span>.str <span class=\\\"hljs-string\\\">\\\"c\\\"</span>)) &lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected a, b, or c\\\"</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<p>Sometimes when using <code>&#x3C;|></code> with more complex parsers, the first parser might consume some input\\nbefore failing, which might mess up the next parser in the <code>&#x3C;|></code> chain.  Use the <code>tries</code>\\nfunction to force a parser to back-track all the way to it's original position if it fails.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">// Without tries, this fails, because the first parser consumes the 9, then fails,</span>\\n<span class=\\\"hljs-comment\\\">// but the next parser wants to consume a digit then a letter.  Using tries makes the</span>\\n<span class=\\\"hljs-comment\\\">// parser fully back-track on failure if it had consumed any input.</span>\\n<span class=\\\"hljs-type\\\">P</span>.tries(<span class=\\\"hljs-type\\\">P</span>.anyDigit *&gt; <span class=\\\"hljs-type\\\">P</span>.anyDigit) <span class=\\\"hljs-comment\\\">// parse a digit, throw it away, then parse another digit</span>\\n&lt;|&gt; (<span class=\\\"hljs-type\\\">P</span>.anyDigit *&gt; <span class=\\\"hljs-type\\\">P</span>.anyAlpha) <span class=\\\"hljs-comment\\\">// parse a digit,throw it away, then parse a letter</span>\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"9a\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Ok(\\\"a\\\")</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">0</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"customizing-the-error-message\\\"><a href=\\\"#customizing-the-error-message\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Customizing the error message</h1>\\n<p>Use the <code>&#x3C;?></code> operator to put a custom error message on a parser.  This is useful\\nif you are composing a more complex parser from smaller parsers, and want a more meaningful error\\nmessage if the parser fails.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.many1(<span class=\\\"hljs-type\\\">P</span>.anyDigit)\\n&lt;?&gt; <span class=\\\"hljs-string\\\">\\\"Expected one or more digits\\\"</span>\\n|&gt; <span class=\\\"hljs-type\\\">P</span>.runParser(<span class=\\\"hljs-string\\\">\\\"abc\\\"</span>) <span class=\\\"hljs-comment\\\">// Belt.Result.Error(ParseError(\\\"Expected one or more digits\\\"))</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code>let _ =\\n  ((P.many1 P.anyDigit) &lt;?&gt; \\\"Expected one or more digits\\\") |&gt;\\n    ((P.runParser \\\"abc\\\") //\\n       ((Belt.Result.Error\\n           (((ParseError (\\\"Expected one or more digits\\\"))[@explicit_arity ])))\\n       [@explicit_arity ]))</code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"checking-that-all-input-is-consumed\\\"><a href=\\\"#checking-that-all-input-is-consumed\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Checking that all input is consumed</h1>\\n<p>To make sure that all the input in the string has been consumed, use the <code>eof</code> (end-of-file) parser.\\nIt's common to use <code>&#x3C;* eof</code> to parse the end of input, because <code>&#x3C;*</code> will just keep what's on\\nthe left side of <code>eof</code>.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-type\\\">P</span>.anyDigit &lt;* <span class=\\\"hljs-type\\\">P</span>.eof <span class=\\\"hljs-comment\\\">// Succeeds for \\\"3\\\" but fails for \\\"3 \\\"</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">1444</span>: syntax error, consider adding a `;<span class=\\\"hljs-char\\\">' before</span></code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"debugging\\\"><a href=\\\"#debugging\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Debugging</h1>\\n<p>Use <code>tap</code> to inspect the result of a successful parse, and the parse position.</p>\\n<p>Use the <code>tapLog</code> function to inject some basic logging anywhere in a parser composition.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code>anyDigit *&gt; anyDigit *&gt; anyAlpha |&gt; tapLog <span class=\\\"hljs-comment\\\">// etc.</span></code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">2990</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<h1 id=\\\"examples\\\"><a href=\\\"#examples\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Examples</h1>\\n<h2 id=\\\"ipv4\\\"><a href=\\\"#ipv4\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>IPv4</h2>\\n<p>E.g. <code>127.0.0.1</code></p>\\n<p>There are many different ways to compose a parser to parse values like this.  Below are just\\nsome examples to show different techniques.</p>\\n\\n    <div class=\\\"redex-codeblock m-tabbed\\\">\\n      <ul>\\n        <li class=\\\"reason s-selected\\\"> RE\\n        <li class=\\\"ml\\\"> ML\\n      </ul>\\n      <div class=\\\"codeblock reason s-selected\\\">\\n        <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-keyword\\\">type</span> t = | <span class=\\\"hljs-type\\\">IPv4</span>(int, int, int, int);\\n<span class=\\\"hljs-keyword\\\">let</span> make = (a, b, <span class=\\\"hljs-built_in\\\">c</span>, d) =&gt; <span class=\\\"hljs-type\\\">IPv4</span>(a, b, <span class=\\\"hljs-built_in\\\">c</span>, d);\\n\\n<span class=\\\"hljs-comment\\\">// Using a tuple and mapTuple4</span>\\n<span class=\\\"hljs-comment\\\">// parse a short (up to 255) and the dot separators</span>\\n(\\n  anyPositiveShort &lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>),\\n  anyPositiveShort &lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>),\\n  anyPositiveShort &lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>),\\n  anyPositiveShort\\n)\\n|&gt; mapTuple4(make)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// Using nested flatMaps and a final map at the end.</span>\\n<span class=\\\"hljs-comment\\\">// These are nested because we have to collect each value as we go, and it has to</span>\\n<span class=\\\"hljs-comment\\\">// be in scope at the end when we want to construct our final value.</span>\\n<span class=\\\"hljs-comment\\\">// Note: language support for sequences of monadic binds (e.g. do notation or the</span>\\n<span class=\\\"hljs-comment\\\">// upcoming let+/let* bindings in OCaml, this becomes a beautiful, flat expression,</span>\\n<span class=\\\"hljs-comment\\\">// almost like imperative code, but with pure FP data structures and functions!</span>\\nanyPositiveShort\\n&gt;&gt;= (\\n  a =&gt;\\n    str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)\\n    &gt;&gt;= (\\n      <span class=\\\"hljs-number\\\">_</span> =&gt;\\n        anyPositiveShort\\n        &gt;&gt;= (\\n          b =&gt;\\n            str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)\\n            &gt;&gt;= (\\n              <span class=\\\"hljs-number\\\">_</span> =&gt;\\n                anyPositiveShort\\n                &gt;&gt;= (\\n                  <span class=\\\"hljs-built_in\\\">c</span> =&gt;\\n                    str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)\\n                    &gt;&gt;= (\\n                      <span class=\\\"hljs-number\\\">_</span> =&gt;\\n                        anyPositiveShort\\n                        &lt;#&gt; (\\n                          d =&gt;\\n                            make(a, b, <span class=\\\"hljs-built_in\\\">c</span>, d)\\n                        )\\n                    )\\n                )\\n            )\\n        )\\n    )\\n)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>);\\n\\n<span class=\\\"hljs-comment\\\">// With a monadic flow, another technique is to map each successive result into</span>\\n<span class=\\\"hljs-comment\\\">// an ever-expanding tuple, and pass the values along that way. This allows you</span>\\n<span class=\\\"hljs-comment\\\">// to have a more flat structure, at the</span>\\n<span class=\\\"hljs-comment\\\">// expense of wrapping and unwrapping tuples at each step.</span>\\n\\n<span class=\\\"hljs-comment\\\">// Using &lt;$&gt; and &lt;*&gt; (with &lt;* and *&gt; helpers)</span>\\n<span class=\\\"hljs-comment\\\">// Our make function is (int, int, int, int) =&gt; IPv4</span>\\n<span class=\\\"hljs-comment\\\">// The first map &lt;$&gt; creates a `Parser.t((int, int, int) =&gt; IPv4)`</span>\\n<span class=\\\"hljs-comment\\\">// and each successive &lt;*&gt; fills another slot in our function,</span>\\n<span class=\\\"hljs-comment\\\">// until we finally collect the 4 args.</span>\\n<span class=\\\"hljs-comment\\\">// The `&lt;* str(\\\".\\\")` reads a \\\".\\\", but throw it away.</span>\\nmake \\n&lt;$&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n&lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)          <span class=\\\"hljs-comment\\\">// read and ignore .</span>\\n&lt;*&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n&lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)          <span class=\\\"hljs-comment\\\">// read and ignore .</span>\\n&lt;*&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n&lt;* str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>)          <span class=\\\"hljs-comment\\\">// read and ignore .</span>\\n&lt;*&gt; anyPositiveShort <span class=\\\"hljs-comment\\\">// collect a positive short</span>\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>)\\n\\n<span class=\\\"hljs-comment\\\">// Using sepBy</span>\\n<span class=\\\"hljs-comment\\\">// Note that sepBy produces a list of the values produced by the value parser,</span>\\n<span class=\\\"hljs-comment\\\">// so we have to manually validate that we got the correct number in our list.</span>\\n<span class=\\\"hljs-comment\\\">// This is done using `&gt;&gt;=`, so we can fail the parse with the `fail` function,</span>\\n<span class=\\\"hljs-comment\\\">// which produces a failing parser.  If we get the 4 values we need, we use pure</span>\\n<span class=\\\"hljs-comment\\\">// to create a parser that produces our desired IPv4 value.</span>\\nanyPositiveShort\\n|&gt; sepBy(str(<span class=\\\"hljs-string\\\">\\\".\\\"</span>))\\n&gt;&gt;= (\\n  <span class=\\\"hljs-comment\\\">// sepBy gives us a list, so we have to pick the parts out</span>\\n  shorts =&gt;\\n    <span class=\\\"hljs-keyword\\\">switch</span> (shorts) {\\n    | [a, b, <span class=\\\"hljs-built_in\\\">c</span>, d] =&gt;\\n      <span class=\\\"hljs-comment\\\">// Use pure here because we need to wrap the result in a parser to satisfy</span>\\n      <span class=\\\"hljs-comment\\\">// the type signature of the &gt;&gt;= function</span>\\n      pure(make(a, b, <span class=\\\"hljs-built_in\\\">c</span>, d))\\n    | <span class=\\\"hljs-number\\\">_</span> =&gt; fail(<span class=\\\"hljs-string\\\">\\\"Expected exactly 4 shorts separated by .\\\"</span>)\\n           <span class=\\\"hljs-comment\\\">// fail produces a `Parser.t(_)` that will always fail</span>\\n    }\\n)\\n|&gt; runParser(<span class=\\\"hljs-string\\\">\\\"127.0.0.1\\\"</span>)</code></pre>\\n      </div>\\n      <div class=\\\"codeblock ml\\\">\\n        <pre class=\\\"hljs lang-ml\\\"><code><span class=\\\"hljs-number\\\">2553</span>: &lt;<span class=\\\"hljs-type\\\">UNKNOWN</span> <span class=\\\"hljs-type\\\">SYNTAX</span> <span class=\\\"hljs-type\\\">ERROR</span>&gt;</code></pre>\\n      </div>\\n    </div>\\n  \\n<p>See the code and tests for more examples.</p>\\n<h1 id=\\\"api-documentation\\\"><a href=\\\"#api-documentation\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>API Documentation</h1>\\n<p>For more details, examples, tests, etc., please refer to the code.  Below is a possibly incomplete\\nlist of parser functions that come with <code>ReludeParse</code>.</p>\\n<h2 id=\\\"basic-operations\\\"><a href=\\\"#basic-operations\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Basic operations</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>runParser</code></td>\\n<td>runs a parser with an input string to produce a \\n<code>Belt.Result</code>\\n with either the value or a \\n<code>ParseError.t</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>unParser</code></td>\\n<td>runs a parser with an input string to produce a \\n<code>Belt.Result</code>\\n with either the value or a \\n<code>ParseError.t</code>\\n (with some additional metadata compared to \\n<code>runParser</code>\\n)</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"core-fp-functions-and-operators\\\"><a href=\\\"#core-fp-functions-and-operators\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Core FP functions and operators</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>map</code>\\n/\\n<code>&#x3C;$></code>\\n/\\n<code>&#x3C;#></code>\\n/\\n<code>&#x3C;$</code>\\n/\\n<code>$></code></td>\\n<td>functor functions for mapping pure functions over a parser</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>apply</code>\\n/\\n<code>&#x3C;*></code>\\n/\\n<code>&#x3C;*</code>\\n/\\n<code>*></code></td>\\n<td>applicative functions for combining parsers</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>&#x3C;^></code></td>\\n<td>combine two parsers to produce a tuple of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>tuple2</code>\\n-\\n<code>5</code></td>\\n<td>combine parsers to produce tuples of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>map2</code>\\n-\\n<code>5</code></td>\\n<td>combine parsers using a function to combine the results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>mapTuple2</code>\\n-\\n<code>5</code></td>\\n<td>combine a tuple of parsers using a function to combine the results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>pure</code></td>\\n<td>lift a pure value into a parser that always succeeds with the value</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>unit</code></td>\\n<td>lift a pure \\n<code>()</code>\\n value into a parser that always succeeds with \\n<code>()</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>flatMap</code>\\n/\\n<code>bind</code>\\n/\\n<code>>>=</code></td>\\n<td>map a function over a parser that can produce a new parser - used for sequencing parsers</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<p><strong>Parsers also get all of the additional utilities provided by all the <code>Relude</code> typeclass extensions.</strong></p>\\n<h2 id=\\\"loggingside-effects\\\"><a href=\\\"#loggingside-effects\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Logging/side effects</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>tap</code></td>\\n<td>runs a side effect function in a parse change, and forwards the given result along</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>tapLog</code></td>\\n<td>logs some information about the current parse position</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"error-customizationhandling\\\"><a href=\\\"#error-customizationhandling\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Error customization/handling</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>withError</code>\\n/\\n<code>flipWithError</code>\\n/\\n<code>&#x3C;?></code></td>\\n<td>provide a custom error message</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>throwError</code></td>\\n<td>Create a parser that fails with the given \\n<code>ParseError.t</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>fail</code></td>\\n<td>Create a parser that fails with the given \\n<code>string</code>\\n message</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>catchError</code></td>\\n<td>Handle a failed parse by converting a \\n<code>ParseError.t</code>\\n into a new parser</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"repeated-values\\\"><a href=\\\"#repeated-values\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Repeated values</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>many</code></td>\\n<td>Run any parser 0 or more times to produce a \\n<code>[]</code>\\n of values (like \\n<code>*</code>\\n in regex)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1</code></td>\\n<td>Run any parser 1 or more times to produce a \\n<code>Relude.NonEmptyList</code>\\n (aka \\n<code>Nel</code>\\n) of values (like \\n<code>+</code>\\n in regex) - the result is a \\n<code>Nel</code>\\n because we are guaranteed to find at least one value, otherwise the parser will fail</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>times</code></td>\\n<td>run a parser \\n<code>count</code>\\n times and produce a \\n<code>[]</code>\\n of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>times2</code>\\n-\\n<code>5</code></td>\\n<td>run a parser exactly twice (up to 5) to produce a tuple of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>timesMin</code></td>\\n<td>run a parser at least n times to produce a list of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>timesMax</code></td>\\n<td>run a parser at most n times to produce a list of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>timesMinMax</code></td>\\n<td>run a parser at least n times and at most m times to produce a list of results</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntilWithEnd</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1UntilWithEnd</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntil</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and discarding the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1Until</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and discarding the consumed terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntilPeekWithEnd</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1UntilPeekWithEnd</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>manyUntilPeek</code></td>\\n<td>parse 0 or more values until a terminator is reached, producing the results and discarding the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>many1UntilPeek</code></td>\\n<td>parse 1 or more values until a terminator is reached, producing the results and discarding the terminator, without consuming the terminator</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"optionaldefault-values\\\"><a href=\\\"#optionaldefault-values\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Optional/default values</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>opt</code></td>\\n<td>attempt a parser, and wrap a success in \\n<code>Some</code>\\n and convert a failure to \\n<code>None</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orDefault</code></td>\\n<td>attempt a parser, and if it fails, produce a default value</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orUnit</code></td>\\n<td>attempt a parser, and if it fails, produce unit</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"delimited-values\\\"><a href=\\\"#delimited-values\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Delimited values</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>between</code></td>\\n<td>parse a value inside opening and closing delimiters</td>\\n<td><code>(abc)</code></td>\\n</tr>\\n<tr>\\n<td><code>sepBy</code></td>\\n<td>parse zero or more values separated by a delimiter</td>\\n<td><code>a,b,c,d</code></td>\\n</tr>\\n<tr>\\n<td><code>sepBy1</code></td>\\n<td>parse one or more values separated by a delimiter</td>\\n<td><code>a,b,c,d</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByOptEnd</code></td>\\n<td>parse zero or more values separated by a delimiter, optionally ending with the delimiter</td>\\n<td><code>a,b,c,d</code>\\n or \\n<code>a,b,c,d,</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByOptEnd1</code></td>\\n<td>parse one or more values separated by a delimiter, optionally ending with the delimiter</td>\\n<td><code>a,b,c,d</code>\\n or \\n<code>a,b,c,d,</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByWithEnd</code></td>\\n<td>parse zero or more delimited values ending with the delimiter</td>\\n<td><code>a,b,c,</code></td>\\n</tr>\\n<tr>\\n<td><code>sepByWithEnd1</code></td>\\n<td>parse one or more delimited values ending with the delimiter</td>\\n<td><code>a,b,c,</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"associative-operators\\\"><a href=\\\"#associative-operators\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Associative operators</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>chainr1</code></td>\\n<td>parse values separated by a right-associative operator (useful for parsing math expressions)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>chainl1</code></td>\\n<td>parse values separated by a left-associative operator (useful for parsing math expressions)</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"trying-different-parsers\\\"><a href=\\\"#trying-different-parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Trying different parsers</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>tries</code></td>\\n<td>Tries a parser, and backtracks all the way to the original start position for the parser on failure.  This is useful if you are using a more complex parser that might consume some input successfully before it fails.  The default behavior is to only backtrack to the start of the failure, whereas this function forces the parse to backtrack to the beginning of the complex parser's input.</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>alt</code>\\n/\\n<code>altLazy</code>\\n/\\n<code>orElse</code>\\n/\\n<code>orElseLazy</code>\\n/\\n<code>&#x3C;pipe></code></td>\\n<td>try a parser, and if it fails, try the other</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyOf</code></td>\\n<td>Attempts to parse a value using a list of potential parsers, tried from left to right</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"validationextraction\\\"><a href=\\\"#validationextraction\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Validation/extraction</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>lookAhead</code>\\n/\\n<code>peek</code></td>\\n<td>Run a parser to produce a value, without consuming any input</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>lookAheadNot</code>\\n/\\n<code>peekNot</code></td>\\n<td>Run a parser which fails if it produces a value, without consuming any input</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>filter</code></td>\\n<td>apply a predicate to the result of a parser to either continue or fail the parse</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getSome</code></td>\\n<td>converts a parser of \\n<code>option('a)</code>\\n into a parser of \\n<code>'a</code>\\n, failing if the value is \\n<code>None</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getNonEmptyStr</code></td>\\n<td>converts a parser of \\n<code>string</code>\\n into a parser of a non-empty \\n<code>string</code>\\n, failing if the value is \\n<code>\\\"\\\"</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getFst</code></td>\\n<td>converts a parser of \\n<code>('a, 'b)</code>\\n into a parser of \\n<code>'a</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>getSnd</code></td>\\n<td>converts a parser of \\n<code>('a, 'b)</code>\\n into a parser of \\n<code>'b</code></td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"text-parsers\\\"><a href=\\\"#text-parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Text parsers</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>eof</code></td>\\n<td>verify that the end of the input has been reached</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orEOF</code></td>\\n<td>attempts a parser, and throws away the result, or if it fails, attempts the \\n<code>eof</code>\\n parser</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyChar</code></td>\\n<td>parses any single character</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>notChar</code></td>\\n<td>parses any single character except the given</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyStr</code></td>\\n<td>parses any string (WARNING: this will likely consume all remaining input)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonEmptyStr</code></td>\\n<td>parses any non-empty (\\n<code>\\\"\\\"</code>\\n) string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>str</code></td>\\n<td>parses the given string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>strIgnoreCase</code></td>\\n<td>parses the given string case-insensitively</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharBy</code></td>\\n<td>parses a character, and checks it with a predicate function</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyOfStr</code></td>\\n<td>parses any of the given strings</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyOfStrIgnoreCase</code></td>\\n<td>parses any of the given strings case insensitively</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>wsList</code></td>\\n<td>parses any amount of whitespace characters and returns them in a list of single chars</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>wsString</code></td>\\n<td>parses any amount of whitespace characters and returns them in a string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>ws</code></td>\\n<td>parses any amount of whitespace characters throws them away (produces \\n<code>()</code>\\n)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharNotIn</code></td>\\n<td>parses any single char not in the given list</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharNotInIgnoreCase</code></td>\\n<td>parses any single char not in the given list, case-insensitive</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyCharInRange</code></td>\\n<td>parses any character in the ASCII code range</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonDigit</code></td>\\n<td>parses any non-digit character</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyLowerCaseChar</code></td>\\n<td>parses a single lowercase letter char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyUpperCaseChar</code></td>\\n<td>parses a single uppercase letter char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyAlpha</code></td>\\n<td>parses any upper or lowercase letter char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyAlphaOrDigit</code></td>\\n<td>parses any upper or lowercase letter or digit char</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>regex</code></td>\\n<td>parses a string matching the given regex</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>regexStr</code></td>\\n<td>parses a string matching the given regex string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftParen</code></td>\\n<td>parses a \\n<code>(</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightParen</code></td>\\n<td>parses a \\n<code>)</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenParens</code></td>\\n<td>parses a value inside \\n<code>(</code>\\n and \\n<code>)</code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftCurly</code></td>\\n<td>parses a \\n<code>{</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightCurly</code></td>\\n<td>parses a \\n<code>}</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenCurlies</code></td>\\n<td>parses a value inside \\n<code>{</code>\\n and \\n<code>}</code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftSquare</code></td>\\n<td>parses a \\n<code>[</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightSquare</code></td>\\n<td>parses a \\n<code>]</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenSquares</code></td>\\n<td>parses a value inside \\n<code>[</code>\\n and \\n<code>]</code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>leftAngle</code></td>\\n<td>parses a \\n<code>&#x3C;</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>rightAngle</code></td>\\n<td>parses a \\n<code>></code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenAngles</code></td>\\n<td>parses a value inside \\n<code>&#x3C;</code>\\n and \\n<code>></code>\\n, consuming extra whitespace padding</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>singleQuote</code></td>\\n<td>parses a \\n<code>'</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenSingleQuotes</code></td>\\n<td>parses a value inside \\n<code>'</code>\\n and \\n<code>'</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>doubleQuote</code></td>\\n<td>parses a \\n<code>'</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenDoubleQuotes</code></td>\\n<td>parses a value inside \\n<code>\\\"</code>\\n and \\n<code>\\\"</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>backTick</code></td>\\n<td>parses a backtick</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>betweenBackTicks</code></td>\\n<td>parses a value inside backticks</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>cr</code></td>\\n<td>parses a \\n<code>\\\\r</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>lf</code></td>\\n<td>parses a \\n<code>\\\\n</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>crlf</code></td>\\n<td>parses a \\n<code>\\\\r\\\\n</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>eol</code></td>\\n<td>parses a \\n<code>\\\\r\\\\n</code>\\n, \\n<code>\\\\r</code>\\n, or a \\n<code>\\\\n</code></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>orEOL</code></td>\\n<td>runs a parser and discards the result, or if it fails, try the \\n<code>eol</code>\\n parser</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"numeric-parsers\\\"><a href=\\\"#numeric-parsers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Numeric parsers</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Function</th>\\n<th>Description</th>\\n<th>Example</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>anyDigit</code></td>\\n<td>parses any single character, makes sure it's a digit 0-9 and produces it as a single character string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyDigitAsInt</code></td>\\n<td>parses any single character, makes sure it's a digit 0-9 and converts it to an int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonEmptyDigits</code></td>\\n<td>parses 1 or more consecutive digits as a string</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonZeroDigit</code></td>\\n<td>parses any non-zero digit character</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonZeroDigitAsInt</code></td>\\n<td>parses any non-zero digit character as an int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyUnsignedInt</code></td>\\n<td>parses an integer with no \\n<code>+</code>\\n or \\n<code>-</code>\\n prefix</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyPositiveInt</code></td>\\n<td>parses a positive integer (optional + prefix)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNegativeInt</code></td>\\n<td>parses a negative integer (- prefix)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyInt</code></td>\\n<td>parses any positive or negative int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyUnsignedShort</code></td>\\n<td>parses a short int</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyDecimal</code></td>\\n<td>parses a decimal value with optional exponential notation</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyHexDigit</code></td>\\n<td>parses any hex digit 0-9 or a-f or A-F</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyNonZeroHexDigit</code></td>\\n<td>parses any hex digit 1-9 or a-f or A-F</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>anyBool</code></td>\\n<td>parses a bool true or false value</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>See the code and tests for a complete list of functions and examples.</p>\\n<h1 id=\\\"extra-utilities\\\"><a href=\\\"#extra-utilities\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Extra Utilities</h1>\\n<p><code>ReludeParse</code> comes with a few higher-level parsers for convenience and for educational\\npurposes.</p>\\n<ul>\\n<li><code>ReludeParse.IPv4</code> - IPv4 addresses</li>\\n<li><code>ReludeParse.IPv6</code> - IPv6 addresses</li>\\n<li><code>ReludeParse.UUID</code> - 8-4-4-4-12 UUIDs</li>\\n<li><code>ReludeParse.NanpPhone</code> - North American Numbering Plan (NANP) phone numbers</li>\\n</ul>\\n<p>Other parsers and utilities for things like <code>URL</code>s and <code>DateTime</code>s can be found in other libraries like\\n<a href=\\\"https://github.com/reazen/relude-url\\\">relude-url</a> and <a href=\\\"https://github.com/reazen/relude-eon\\\">relude-eon</a>.</p>\\n\",\"homepageUrl\":\"https://github.com/reazen/relude-parse#readme\",\"repositoryUrl\":\"https://github.com/reazen/relude-parse\",\"npmUrl\":\"https://www.npmjs.com/package/relude-parse\",\"issuesUrl\":\"https://github.com/reazen/relude-parse/issues\",\"slug\":\"/package/relude-parse\"}},\"pathContext\":{\"id\":\"relude-parse\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/package-relude-parse.json\n// module id = 1414\n// module chunks = 229139762612574"],"sourceRoot":""}